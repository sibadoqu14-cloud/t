


import { GoogleGenAI, Type } from "@google/genai";

// API key is now sourced from environment variables for security and correctness.
const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

// The complete book stylesheet, incorporating user-provided screen and print styles
// to serve as a reliable template for the AI model.
const ALL_BOOK_STYLES = `
    /* --- SCREEN STYLES (For Web Preview) --- */
    @import url('https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700&display=swap');

    body {
        font-family: 'Vazirmatn', sans-serif;
        background-color: #fff;
        color: #000;
        direction: rtl;
        line-height: 1.8;
    }

    .page {
        padding: 20px;
        margin-bottom: 20px;
        position: relative;
        border: 1px solid #ccc;
        box-sizing: border-box;
    }

    /* General Layouts */
    .two-column {
        column-count: 2;
        column-gap: 40px;
    }

    .three-column {
        display: flex;
        justify-content: space-between;
        gap: 40px;
    }

    .three-column > div {
        flex: 1;
    }

    /* TOC Page Styles */
    .toc-chapter-header {
        position: absolute;
        top: 20px;
        left: 20px;
        text-align: left;
        inset-inline-start: 20px;
        inset-block-start: 20px;
    }

    .toc-chapter-label {
        font-family: 'Vazirmatn', serif;
        font-size: 2.2em;
        color: #a9a9a9;
    }

    .toc-chapter-number {
        font-family: 'Vazirmatn', serif;
        font-size: 7em;
        color: #333;
        line-height: 1;
        vertical-align: middle;
        margin-left: -15px;
    }

    .toc-main-title {
        font-family: 'Vazirmatn', serif;
        text-align: center;
        font-size: 2.8em;
        color: #5c7e66;
        font-weight: normal;
        margin-top: 100px;
        margin-bottom: 50px;
    }

    .toc-section {
        display: flex;
        justify-content: space-between;
    }

    .toc-section-title {
        font-weight: bold;
        color: #6a8a6b;
        margin-top: 20px;
    }

    .toc-subsection {
        display: flex;
        justify-content: space-between;
        margin-right: 15px;
    }

    .page-number {
        text-align: left;
        margin-top: 80px;
        font-size: 0.9em;
    }

    /* Content Page Styles */
    .content-header-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: #a9bd9a;
        padding: 5px 15px;
        font-weight: bold;
        color: white;
    }

    .content-header-bar .page-num {
        font-size: 1.1em;
    }

    .content-header-bar .title {
        font-size: 1.1em;
        color: #3f5d45;
    }

    .content-section-title {
        background-color: #6a8a6b;
        color: white;
        padding: 8px;
        text-align: center;
        font-weight: bold;
        font-size: 1.1em;
        margin-bottom: 15px;
    }

    .content-heading {
        font-family: 'Vazirmatn', sans-serif;
        color: #5c7e66;
        font-weight: bold;
        font-size: 1.3em;
        margin-bottom: 10px;
    }

    ul.custom-list {
        list-style: none;
        padding-right: 0;
        margin-right: 0;
    }

    ul.custom-list > li {
        position: relative;
        padding-right: 25px;
        margin-bottom: 10px;
    }

    ul.custom-list > li::before {
        content: '●';
        position: absolute;
        right: 0;
        top: 0px; /* Adjust as needed */
        color: #6a8a6b;
        font-size: 1.2em;
    }

    ul.custom-list ul {
        list-style: none;
        padding-right: 20px;
        margin-top: 10px;
    }

    ul.custom-list ul li {
        position: relative;
        padding-right: 25px;
        margin-bottom: 5px;
    }

    ul.custom-list ul li::before {
        content: '○';
        position: absolute;
        right: 0;
        top: 0px; /* Adjust as needed */
        color: #000;
    }

    .image-container {
        margin-top: 20px;
        padding: 0 15px;
    }

    .image-row {
        display: flex;
        justify-content: center;
        gap: 10px;
        flex-wrap: wrap; /* Allows items to wrap to the next line */
    }

    .image-placeholder {
        width: 48%;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 10px; /* Adds some space below images in a grid */
    }

    .image-placeholder img {
        max-width: 100%;
        height: auto;
        display: block;
    }

    .image-placeholder.fit-fixed {
        width: 220px;
        height: 320px;
        overflow: hidden;
    }
    
    .image-placeholder.fit-rectangle {
        width: 320px;
        height: 420px;
        overflow: hidden;
    }

    .image-placeholder.fit-fixed img,
    .image-placeholder.fit-rectangle img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        object-position: center;
    }

    .image-label {
        position: absolute;
        right: 10px;
        left: auto;
        bottom: 10px;
        background-color: white;
        border-radius: 50%;
        border: 1px solid black;
        width: 25px;
        height: 25px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
    }
    
    /* --- NEW, STRUCTURED LAYOUT SYSTEM --- */
    .layout-container::after {
        content: "";
        display: table;
        clear: both;
    }

    .image-float-block {
        width: 45%; /* A sensible default width for floated blocks */
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    
    /* Make images inside the float block responsive to its container */
    .image-float-block .image-placeholder {
        width: 100%; 
        margin-bottom: 0; /* Gap is handled by the parent */
    }

    .image-float-block.float-right {
        float: right;
        margin-left: 15px;
        margin-bottom: 10px;
    }

    .image-float-block.float-left {
        float: left;
        margin-right: 15px;
        margin-bottom: 10px;
    }

    .caption {
        text-align: right;
        font-size: 0.9em;
        color: #333;
        margin-top: 10px;
        line-height: 1.6;
    }

    .caption span {
       text-decoration: underline;
       color: #4a6a4b;
    }

    /* Styles for Content Table */
    .content-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
        margin-bottom: 30px;
        font-size: 0.9em;
    }

    .content-table th, .content-table td {
        border: 1px solid #ccc;
        padding: 8px 10px;
        text-align: right;
        vertical-align: top;
    }

    .content-table thead th {
        background-color: #a9bd9a;
        color: #3f5d45;
        font-weight: bold;
    }

    .content-table .section-header td {
        background-color: #6a8a6b;
        color: white;
        font-weight: bold;
        text-align: center;
    }

    .content-table tbody tr:nth-child(even) {
        background-color: #f2f2f2;
    }
    .content-table .section-header + tr {
         background-color: #fff !important; /* Row after section header should be white */
    }
    .content-table .section-header + tr + tr {
         background-color: #f2f2f2 !important;
    }

    .content-table ul {
        list-style-type: disc;
        padding-right: 20px;
        margin: 0;
    }

    .content-table ul li {
        margin-bottom: 5px;
    }

    /* Style for TIP boxes */
    .tip-box {
        border: 1px solid #a9bd9a;
        background-color: #f5f8f3;
        padding: 12px;
        margin-top: 20px;
        font-size: 0.95em;
        line-height: 1.7;
        border-radius: 4px;
    }

    .tip-box strong {
        color: #5c7e66;
    }


    /* --- PRINT STYLES (For PDF Output) --- */
    @media print {
        /* Default @page rule for content pages: applies 'nano margin' */
        @page {
            size: A4 portrait;
            margin: 0;
        }

        /* A named @page rule for the Table of Contents to restore default margins */
        @page toc {
            margin: 10mm; /* A standard margin for the TOC page */
        }

        * {
            -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
        }

        html, body {
            margin: 0;
            padding: 0;
            overflow: visible;
        }

        body {
            font-size: 10pt;
            line-height: 1.4;
        }

        /* General page settings */
        .page {
            page-break-after: always;
            page-break-inside: avoid;
            padding: 10px; /* Inner padding to prevent text from touching the edge */
            margin: 0;
            border: none;
            box-sizing: border-box;
            width: 100%;
        }
        
        /* Apply the named 'toc' page rule to the Table of Contents page */
        .page.page-toc {
            page: toc;
        }

        .page:last-child {
            page-break-after: avoid !important;
        }

        /* فهرست مطالب */
        .toc-chapter-header {
            position: absolute; top: 10px; left: 10px;
        }
        .toc-chapter-label { font-size: 1.8em; }
        .toc-chapter-number { font-size: 5.5em; margin-left: -10px; }
        .toc-main-title { margin-top: 80px; margin-bottom: 40px; font-size: 2.5em; }
        .three-column { display: flex; flex-wrap: nowrap; gap: 25px; }
        .three-column > div { flex: 1; min-width: 0; }
        .toc-section { margin-top: 12px; margin-bottom: 8px; font-size: 0.95em; }
        .toc-section-title { margin-top: 15px; }
        .toc-subsection { margin-top: 6px; margin-bottom: 6px; font-size: 0.9em; }
        .page-number { margin-top: 60px; }

        /* صفحات محتوا */
        .content-header-bar {
            padding: 4px 12px !important;
            margin-bottom: 5px !important;
        }
        .content-section-title {
            margin-bottom: 8px !important;
            padding: 4px !important;
            font-size: 1em !important;
        }
        .content-heading {
            margin-top: 8px !important;
            margin-bottom: 4px !important;
            font-size: 1.1em !important;
        }
        .two-column {
            column-count: 2;
            column-gap: 20px;
            margin-top: 5px !important;
        }

        /* کاهش شدید فاصله‌ها برای فشرده‌سازی */
        p {
            margin-top: 2px !important;
            margin-bottom: 3px !important;
            text-align: justify !important;
            line-height: 1.35 !important;
            orphans: 2;
            widows: 2;
        }
        ul.custom-list {
            margin-top: 4px !important;
            margin-bottom: 4px !important;
        }
        ul.custom-list > li {
            margin-bottom: 3px !important;
            line-height: 1.35 !important;
        }
        ul.custom-list ul li {
            margin-bottom: 2px !important;
        }

        /* تصاویر */
        .image-container {
            margin-top: 10px !important;
            break-inside: avoid !important; /* Modern property */
            page-break-inside: avoid !important; /* Legacy property */
        }
        /* ... استایل‌های تصویر بدون تغییر ... */

        /* استایل‌های جدید و بهینه‌شده برای جدول محتوا (صفحه ۵۰۸) */
        .content-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 5px !important;
            margin-bottom: 15px !important;
            font-size: 8.5pt !important; /* کاهش اندازه فونت جدول */
            line-height: 1.25 !important; /* کاهش فاصله خطوط جدول */
        }
        .content-table caption {
            font-size: 9pt;
            margin-bottom: 4px;
            font-weight: bold;
            text-align: center;
        }
        .content-table th, .content-table td {
            border: 1px solid #aaa;
            padding: 4px 5px !important; /* کاهش پدینگ سلول‌ها */
            text-align: right;
            vertical-align: top;
        }
        .content-table thead th {
            background-color: #a9bd9a;
            color: #3f5d45;
            font-weight: bold;
        }
        .content-table .section-header td {
            background-color: #6a8a6b;
            color: white;
            font-weight: bold;
            text-align: center;
            padding: 5px !important;
        }
        .content-table ul {
            list-style-type: disc;
            padding-right: 15px !important;
            margin: 2px 0 !important;
        }
        .content-table ul li {
            margin-bottom: 2px !important;
        }

        /* کاهش فاصله برای عناوین خاص صفحه ۵۰۸ */
        #signs-title {
            margin-top: 10px !important;
            margin-bottom: 5px !important;
        }
        #signs-content {
            margin-top: 0 !important;
        }
        #signs-content h4 {
            margin-top: 5px !important;
            margin-bottom: 2px !important;
        }
        /* Styles for 2x2 image grid */
        .image-row {
            flex-wrap: wrap !important;
        }
        .image-placeholder {
            margin-bottom: 5px !important;
        }
        /* Style for TIP boxes in Print */
        .tip-box {
            border: 1px solid #aaa;
            padding: 6px !important;
            margin-top: 15px !important;
            font-size: 8.5pt !important;
            line-height: 1.3 !important;
            page-break-inside: avoid;
        }
        .tip-box strong {
            font-weight: bold;
        }
    }
`;


export const getFullHtmlDocument = (pages: string[]) => {
    const pagesHtml = pages.join('\n\n');
    return `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Translated Book</title>
    <style>${ALL_BOOK_STYLES}</style>
</head>
<body>
    ${pagesHtml}
</body>
</html>`;
};


async function fileToGenerativePart(file: File) {
  const base64EncodedData = await new Promise<string>((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => resolve((reader.result as string).split(',')[1]);
    reader.onerror = (err) => reject(err);
    reader.readAsDataURL(file);
  });
  return { inlineData: { data: base64EncodedData, mimeType: file.type } };
}

export const convertImageToBookLayout = async (
    imageFile: File,
    targetLanguage: 'Persian' | 'English',
    onProgress: (progressKey: string) => void
): Promise<{ analysis: any; html_code: string }> => {
    onProgress('progress.step1');
    
    const model = 'gemini-2.5-flash';
    const imagePart = await fileToGenerativePart(imageFile);
    
    const translationInstruction = targetLanguage === 'Persian'
        ? 'Translate all text content from the source language (likely English) into high-quality Persian.'
        : 'Translate all text content from the source language (likely Persian) into high-quality English.';

    const directionInstruction = targetLanguage === 'Persian'
        ? 'Set the text direction on the page div: `dir="rtl"` for Persian.'
        : 'Set the text direction on the page div: `dir="ltr"` for English.';

    const prompt = `
You are a world-class book layout designer and translator. Your task is to analyze an image of a book page, translate its content with exceptional quality into the specified target language, and generate a professional, structured HTML layout for it. Your primary objective is to replicate the source image's layout with high fidelity.

**Target Language for this page: ${targetLanguage}**

Your entire output must be a single, valid JSON object that adheres to this schema:
{
  "analysis": {
    "subject": "string",
    "source_language": "string",
    "target_language": "string"
  },
  "html_code": "string"
}

Follow these instructions to populate the JSON fields:

1.  **\`analysis\` object**:
    -   \`subject\`: A brief summary of the page's subject matter.
    -   \`source_language\`: The detected source language (e.g., 'Persian' or 'English').
    -   \`target_language\`: This **must** be '${targetLanguage}'.

2.  **\`html_code\` string**:
    -   ${translationInstruction} Maintain the original tone and meaning.
    -   Create a clean and semantic HTML layout. The entire layout for the page **must** be wrapped in a single \`<div class="page">...</div>\`.
    -   ${directionInstruction} This is crucial for correct rendering.
    -   If you identify the page as a Table of Contents, add an additional class \`page-toc\` to the main wrapper: \`<div class="page page-toc">...</div>\`.
    -   For any images, use a placeholder: \`<img data-placeholder-id="image-1" src="#" alt="A descriptive alt text for the image content.">\`. Increment the number for each subsequent image (image-2, image-3, etc.).

**Critical Instructions for Image and Text Layout (NEW STRUCTURED SYSTEM):**
Your primary goal is to fit the visual layout from the image into a predefined HTML structure using specific classes. You are not to improvise the layout logic.

1.  **Analyze the layout:** Determine if there are images positioned to the side of a block of text (floated images).

2.  **Use the Structured Layout System:**
    -   **If you detect floated images:** You MUST use the following precise HTML structure.
        -   The entire section containing the floated images and the text that wraps around them MUST be enclosed in a \`<div class="layout-container">\`.
        -   All the floated images (whether it's one or a stack of several) MUST be grouped together inside a single \`<div class="image-float-block">\`.
        -   You MUST add either a \`float-left\` or \`float-right\` class to the \`.image-float-block\` div to control its position, like this: \`<div class="image-float-block float-right">\`.
        -   The text that wraps around the images should come *after* the \`image-float-block\` div, but still *inside* the \`layout-container\`.

    -   **Example of a single floated image on the right:**
        \`\`\`html
        <div class="layout-container">
            <div class="image-float-block float-right">
                <div class="image-placeholder">
                    <img data-placeholder-id="image-1" src="#" alt="Description">
                </div>
            </div>
            <p>This is the text that will wrap around the image. It follows the image block in the HTML structure.</p>
        </div>
        \`\`\`

    -   **Example of two stacked images floated on the left:**
        \`\`\`html
        <div class="layout-container">
            <div class="image-float-block float-left">
                <div class="image-placeholder">
                    <img data-placeholder-id="image-1" src="#" alt="Description of first image">
                </div>
                <div class="image-placeholder">
                    <img data-placeholder-id="image-2" src="#" alt="Description of second image">
                </div>
            </div>
            <h4>A Heading</h4>
            <p>This is the text that will wrap around the stacked images. It flows naturally next to the floated block.</p>
        </div>
        \`\`\`

    -   **For Full-Width or Centered Images:** If images are NOT floated next to text (e.g., they span the full width, are in their own rows, or are part of a grid without wrapping text), use the standard \`.image-row\` and \`.image-placeholder\` classes as before. DO NOT use the \`.layout-container\` or \`.image-float-block\` for these cases.

Follow these structural rules strictly. Your task is to correctly identify the layout type from the image and apply the corresponding, predefined HTML structure.

**Full CSS Stylesheet (for reference):**
Here is the complete CSS that will be applied to your generated HTML. Your HTML structure must correctly use these classes to replicate the layout.

\`\`\`css
${ALL_BOOK_STYLES}
\`\`\`

You **must** strictly use only the CSS classes defined in the stylesheet above. Do not use inline styles, and do not invent new classes. The HTML should be semantic and well-structured.

Remember, the final output must be a single, valid JSON object with no extra text or explanations.
`;

    const responseSchema = {
        type: Type.OBJECT,
        properties: {
            analysis: {
                type: Type.OBJECT,
                properties: {
                    subject: { type: Type.STRING, description: "A brief summary of the page's subject matter." },
                    source_language: { type: Type.STRING, description: "The detected source language of the text (e.g., 'Persian' or 'English')." },
                    target_language: { type: Type.STRING, description: `The language the text was translated into. This must be '${targetLanguage}'.` },
                },
                required: ['subject', 'source_language', 'target_language']
            },
            html_code: { type: Type.STRING, description: "The full HTML code for the laid-out page, adhering to the provided CSS classes." },
        },
        required: ['analysis', 'html_code']
    };

    try {
        const geminiConfig = {
            responseMimeType: 'application/json',
            responseSchema: responseSchema,
            temperature: 0.4,
        };
        
        const response = await ai.models.generateContent({
            model: model,
            contents: [{ parts: [imagePart, { text: prompt }] }],
            config: geminiConfig,
        });
        
        onProgress('progress.step2');
        const resultText = response.text;

        if (!resultText) {
            console.error("Gemini API returned an empty response text.", response);
            const finishReason = response.candidates?.[0]?.finishReason;
            if (finishReason === 'SAFETY') {
                throw new Error('geminiErrors.safety');
            }
            if (finishReason === 'RECITATION') {
                throw new Error('geminiErrors.recitation');
            }
            throw new Error('geminiErrors.empty');
        }

        const resultJson = JSON.parse(resultText);

        onProgress('progress.pageSuccess');
        return resultJson;
    } catch (error) {
        console.error("Error during Gemini API call or processing:", error);
        let errorKey = 'geminiErrors.unknown';
        if (error instanceof Error) {
            // Check if the message is already a key
            if (error.message.startsWith('geminiErrors.')) {
                errorKey = error.message;
            }
        }
        
        if (error instanceof SyntaxError) {
            errorKey = 'geminiErrors.invalidJson';
        }

        onProgress(`error:${errorKey}`);
        throw new Error(errorKey);
    }
};


export const verifyAndRefinePage = async (
    imageFile: File,
    originalHtml: string,
    targetLanguage: 'Persian' | 'English',
): Promise<{ changesMade: boolean; html: string }> => {
    const model = 'gemini-2.5-pro';
    const imagePart = await fileToGenerativePart(imageFile);

    const prompt = `
You are an expert book editor and translator performing a final quality check. You will be given an image of a book page and the corresponding HTML code. Your task is to meticulously review the HTML against the image and decide if any corrections are needed.

**Target Language for Translation: ${targetLanguage}**

Your entire output MUST be a single, valid JSON object that adheres to this schema:
{
  "changes_needed": "boolean",
  "explanation": "string",
  "refined_html_code": "string"
}

Follow these instructions to populate the JSON fields:

1.  **Content and Translation Review**:
    -   Carefully compare the text content in the image with the text in the HTML. Are any words, sentences, or paragraphs missing?
    -   Scrutinize the translation quality. Are there any grammatical errors, awkward phrasing, or inaccurate translations?

2.  **Populate JSON based on your review**:
    -   **If you found ANY missing content or translation errors**:
        -   Set \`changes_needed\` to \`true\`.
        -   In \`explanation\`, briefly describe the corrections you made (e.g., "Added a missing sentence and corrected a translation error.").
        -   In \`refined_html_code\`, provide the **complete and corrected HTML code**. It is crucial that you PRESERVE THE ORIGINAL HTML STRUCTURE AND CSS CLASSES. Only modify the text content where necessary.
    -   **If the HTML is perfect and needs no changes**:
        -   Set \`changes_needed\` to \`false\`.
        -   In \`explanation\`, state that no changes were necessary (e.g., "The content and translation are accurate.").
        -   In \`refined_html_code\`, return the **original, unmodified HTML code** that was provided to you.

**IMPORTANT**: Your primary goal is to refine the text content. Do NOT alter the HTML structure (tags, attributes, classes) unless it's absolutely essential to insert missing text.

The final output must be only the JSON object, with no other text or explanation.

**Original HTML to review:**
\`\`\`html
${originalHtml}
\`\`\`
`;

    const responseSchema = {
        type: Type.OBJECT,
        properties: {
            changes_needed: { type: Type.BOOLEAN, description: "Set to true if any corrections were made, otherwise false." },
            explanation: { type: Type.STRING, description: "A brief explanation of the changes made, or a confirmation that none were needed." },
            refined_html_code: { type: Type.STRING, description: "The final HTML code. This will be the corrected version if changes were made, or the original version if no changes were needed." }
        },
        required: ['changes_needed', 'explanation', 'refined_html_code']
    };

    try {
        const response = await ai.models.generateContent({
            model: model,
            contents: [{ parts: [imagePart, { text: prompt }] }],
            config: {
                responseMimeType: 'application/json',
                responseSchema: responseSchema,
                temperature: 0.2,
                thinkingConfig: { thinkingBudget: 32768 },
            },
        });

        const resultText = response.text;

        if (!resultText) {
            console.error("Gemini API returned an empty response for verification.", response);
             const finishReason = response.candidates?.[0]?.finishReason;
            if (finishReason === 'SAFETY') {
                throw new Error('geminiErrors.safety');
            }
            throw new Error('geminiErrors.empty');
        }
        
        const resultJson = JSON.parse(resultText);
        return {
            changesMade: resultJson.changes_needed,
            html: resultJson.refined_html_code
        };

    } catch (error) {
        console.error("Error during Gemini verification API call:", error);
        let errorKey = 'geminiErrors.unknown';
        if (error instanceof Error && error.message.startsWith('geminiErrors.')) {
            errorKey = error.message;
        } else if (error instanceof SyntaxError) {
            errorKey = 'geminiErrors.invalidJson';
        }
        throw new Error(errorKey);
    }
};